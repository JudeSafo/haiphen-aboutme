// cve-matcher.ts â€” CVE correlation engine: matches asset metadata against D1 CVE database

export interface AssetMetadata {
  vendor?: string;
  product?: string;
  version?: string;
  firmware?: string;
  os?: string;
}

export interface CveMatch {
  cve_id: string;
  vendor: string;
  product: string;
  cvss_score: number;
  severity: string;
  description: string;
  remediation: string | null;
  affected_versions: string[];
  match_confidence: number; // 0-1
}

export interface ScanFinding {
  severity: string;
  cve: string | null;
  title: string;
  affected_asset: string;
  cvss_score: number;
  remediation: string | null;
  match_confidence: number;
}

export interface ScanSummary {
  total: number;
  critical: number;
  high: number;
  medium: number;
  low: number;
  info: number;
  risk_score: number; // 0-100 composite
}

export async function matchCves(
  db: D1Database,
  target: string,
  metadata: AssetMetadata
): Promise<{ findings: ScanFinding[]; summary: ScanSummary }> {
  const findings: ScanFinding[] = [];

  // Build query conditions based on available metadata
  const conditions: string[] = [];
  const bindings: string[] = [];

  if (metadata.vendor) {
    conditions.push("LOWER(vendor) = LOWER(?)");
    bindings.push(metadata.vendor);
  }
  if (metadata.product) {
    conditions.push("LOWER(product) = LOWER(?)");
    bindings.push(metadata.product);
  }

  // If no vendor/product specified, do a broad search
  if (conditions.length === 0) {
    conditions.push("1=1");
  }

  const whereClause = conditions.join(" AND ");
  const query = `SELECT cve_id, vendor, product, affected_versions, cvss_score, severity, description, remediation
    FROM secure_cve_database
    WHERE ${whereClause}
    ORDER BY cvss_score DESC
    LIMIT 50`;

  const stmt = db.prepare(query);
  const result = await (bindings.length > 0 ? stmt.bind(...bindings) : stmt).all<{
    cve_id: string;
    vendor: string;
    product: string;
    affected_versions: string;
    cvss_score: number;
    severity: string;
    description: string;
    remediation: string | null;
  }>();

  for (const row of result.results) {
    const affectedVersions: string[] = JSON.parse(row.affected_versions || "[]");
    const confidence = computeConfidence(metadata, row.vendor, row.product, affectedVersions);

    if (confidence > 0) {
      findings.push({
        severity: row.severity,
        cve: row.cve_id,
        title: row.description.length > 120 ? row.description.slice(0, 117) + "..." : row.description,
        affected_asset: target,
        cvss_score: row.cvss_score,
        remediation: row.remediation,
        match_confidence: confidence,
      });
    }
  }

  // Sort by CVSS score descending
  findings.sort((a, b) => b.cvss_score - a.cvss_score);

  const summary = computeSummary(findings);
  return { findings, summary };
}

function computeConfidence(
  metadata: AssetMetadata,
  cveVendor: string,
  cveProduct: string,
  affectedVersions: string[]
): number {
  let score = 0;

  // Vendor match
  if (metadata.vendor && cveVendor.toLowerCase() === metadata.vendor.toLowerCase()) {
    score += 0.3;
  } else if (metadata.vendor) {
    // Partial match
    if (cveVendor.toLowerCase().includes(metadata.vendor.toLowerCase()) ||
        metadata.vendor.toLowerCase().includes(cveVendor.toLowerCase())) {
      score += 0.15;
    } else {
      return 0; // vendor mismatch = no match
    }
  }

  // Product match
  if (metadata.product && cveProduct.toLowerCase() === metadata.product.toLowerCase()) {
    score += 0.3;
  } else if (metadata.product) {
    if (cveProduct.toLowerCase().includes(metadata.product.toLowerCase()) ||
        metadata.product.toLowerCase().includes(cveProduct.toLowerCase())) {
      score += 0.15;
    }
  } else {
    score += 0.1; // no product specified = broad match
  }

  // Version match
  if (metadata.version && affectedVersions.length > 0) {
    const versionMatch = affectedVersions.some(range => isVersionInRange(metadata.version!, range));
    if (versionMatch) {
      score += 0.4;
    } else {
      score += 0.1; // version doesn't match but vendor/product do
    }
  } else {
    score += 0.2; // no version specified = assume possible
  }

  return Math.min(score, 1);
}

function isVersionInRange(version: string, range: string): boolean {
  // Handle ranges like "7.4.0-7.4.2", "V2.0-V3.0.3", "multiple"
  if (range === "multiple") return true;

  const cleanV = version.replace(/^[Vv]/, "").trim();
  const dashIndex = range.indexOf("-");

  if (dashIndex === -1) {
    // Single version
    return range.replace(/^[Vv]/, "").trim() === cleanV;
  }

  const low = range.slice(0, dashIndex).replace(/^[Vv]/, "").trim();
  const high = range.slice(dashIndex + 1).replace(/^[Vv]/, "").trim();

  return compareVersions(cleanV, low) >= 0 && compareVersions(cleanV, high) <= 0;
}

function compareVersions(a: string, b: string): number {
  const pa = a.split(".").map(s => parseInt(s, 10) || 0);
  const pb = b.split(".").map(s => parseInt(s, 10) || 0);
  const len = Math.max(pa.length, pb.length);

  for (let i = 0; i < len; i++) {
    const va = pa[i] || 0;
    const vb = pb[i] || 0;
    if (va !== vb) return va - vb;
  }
  return 0;
}

function computeSummary(findings: ScanFinding[]): ScanSummary {
  const counts = { critical: 0, high: 0, medium: 0, low: 0, info: 0 };
  let totalCvss = 0;

  for (const f of findings) {
    const key = f.severity as keyof typeof counts;
    if (key in counts) counts[key]++;
    totalCvss += f.cvss_score;
  }

  // Risk score: weighted severity count normalized to 0-100
  const riskScore = Math.min(100, Math.round(
    (counts.critical * 25 + counts.high * 15 + counts.medium * 8 + counts.low * 3 + counts.info * 1) *
    (findings.length > 0 ? 1 : 0)
  ));

  return {
    total: findings.length,
    ...counts,
    risk_score: riskScore,
  };
}
